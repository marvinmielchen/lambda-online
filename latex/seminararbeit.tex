\documentclass[ngerman]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{csquotes}
\MakeOuterQuote{"}

\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[style=ieee]{biblatex}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{titling}

\addbibresource{literatur.bib}

\newcommand{\subtitle}[1]{
  \posttitle{
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.5em}%
}

\newcommand{\doublelinebreak}{\par\vspace{\baselineskip}}

\title{Implementierung eines Interpreters für eine rudimentäre Programmiersprache auf Basis des untypisierten Lambda-Kalküls unter Verwendung von De-Bruijn-Indizes}
\author{Marvin Mielchen}
\subtitle{Hausarbeit aus dem Seminar: Grundlagen und Meilensteine der funktionalen Programmierung}
\date{\today}

\begin{document}

\maketitle

%\cite[S. 8]{nystrom}
- es muss einen Teil in der Arbeit geben der sich mit den Limitierungen der Arbeit beschäftigt
    - probleme mit rekusion in lambo
    - probleme mit speicher in lambo: z.B. sind while schleifen über große arrays wahrscheinlich nicht möglich weil alle expressions ausgewertet werden müssen und
    das also nicht "echt" iterativ ist
    - usw.
- DER Lambda Kalkül (üpberall ausbessern)

\section{Einleitung}

\subsection{Hintergrund und Motivation}

Im Jahr 1936 veröffentlichte Alonzo Church seine Arbeit (AUSFÜLLEN!!!) in der er den Lambda-Kalkül einführte. 
Der Lambda-Kalkül ist eine formale Sprache, die zur Untersuchung von Funktionen und deren Auswertung dient. Er ist die Grundlage der funktionalen Programmierung und hat einen großen Einfluss auf die Entwicklung von Programmiersprachen wie Lisp, ML, Haskell und vielen anderen.
Mit dem Lambda-Kalkül gibt es neben dem gängigen Modell der Turingmaschine ein weiteres Modell der Berechenbarkeit. Alle Berechnungen, die mit einer Turingmaschine durchgeführt werden können, können auch mit dem Lambda-Kalkül durchgeführt werden und umgekehrt.
Gleichzeitig entsprechen die Probleme die von Turingmaschinen gelöst werden können genau den intuitiv berechenbaren Problemen und das gilt so also auch für die Probleme, die mit dem Lambda-Kalkül modeliert werden können.
Der Lambda-Kalkül ist also ein universelles Modell der Berechenbarkeit und ist damit ein wichtiger Bestandteil der theoretischen Informatik. Viele Funktionale Sprachen werden auf den Grundlagen des Lambda Kalküls aufgebaut obwol unsere modernen Rechner mit ihrer von Neuman Architektur (CITE!) eher zu dem Modell der Turingmaschine passen.
Wie ein komplex verschachtelter Lambda Ausdruck mit einem imperativen System ausgewertet werden kann ist also eine interressante und komplizierte Problemstellung und soll die Motivation für diese Arbeit sein.

\subsection{Ziel der Hausarbeit}

- es soll auf der basis des untypisierten lambda Kalküls eine Sprache entwickelt werden die turingvollstäding (wenn auch nicht praktisch ist)
    - es werden also nur die allernötigsten features implementiert und entscheidende Eigenschaften einer "nützlichen" Sprache gegen Funktionalität eingetauscht die eine einfache und verständliche Interaktion mit den Regeln des Lambda Kalküls ermöglichen
- es soll ein Tree-Walk Interpreter entwickelt werden der die Sprache auswertet und dabei grundlegenden Anforderungen an einen modernen Interpreter und Ansprüchen an solche Implementationen zumindest im Ansatz gerecht wird 
- (optional) villeicht noch evaluation in irgendeiner form und vergleich mit anderen Sprachen 
- auch limitierungen der implementation betrachten (die sind schon schwerwiegend)

- im Anhang kann noch auf die Website eingegangen werden die eine Interaktion mit der entwickelten Sprache ermöglicht

\subsection{Übersicht über die folgenden Abschnitte}

\section{Grundlagen}

\subsection{Lambda-Kalkül}

\subsubsection{Syntax und Regeln im untypisierten Lambda-Kalkül !!ZITATE!!}

Der Lambda-Kalkül beschreibt eine formale Sprache, die zur Definition und Analyse von Funktionen verwendet wird und dieselbe Klasse von berechenbaren Funktionen definiert wie die Turing-Maschine.
In der einfachsten Form lässt sich diese Sprache wie folgt rekursiv in Bakus Naur Form definieren:
\begin{align*}
    \text{\textless term\textgreater} & ::= \text{\textless variable\textgreater} \\
                      & \; | \; ( \lambda \text{\textless variable\textgreater} . \text{\textless term\textgreater} )\\
                      & \; | \; (\text{\textless term\textgreater} \; \text{\textless term\textgreater})
\end{align*}
Ein Lambda Term is dabei in einer der drei definierten Formen, wobei diese wiederum aus verschachtelten Lambda Termen bestehen können.

Eine Variable $\text{\textless variable\textgreater}$ kann im Lambda-Lalkül eine beliebige Zeichenketten sein (z.B. "x" oder "supervar") soweit keine der folgenden Zeichen enthalten ist: $\lambda$ . ( ). Variablen werden dabei als Platzhalter für beliebige Lambda Terme verwendet oder als formale Parameter von Abstraktionen und können dabei auch mehrfach in einem Lambda Term vorkommen.

$(\lambda \text{\textless variable\textgreater} . \text{\textless term\textgreater})$ heist Abstraktion und representiert eine Funktion. Die Variable ist dabei der formale Funktionsparameter und der Lambda Term nach dem Punkt ist der Funktionskörper. Ein Beispiel für eine Abstraktion ist die Identitätsfunktion $(\lambda x.x)$ welche ein Argument entgegennimmt und dieses unverändert zurückgibt.

$(\text{\textless term\textgreater} \; \text{\textless term\textgreater})$ heist Applikation und representiert den Aufruf einer Funktion. Der erste Lambda Term ist dabei die Funktion und der zweite Lambda Term ist das Argument. Die Applikation wird dabei von links nach rechts ausgewertet. Der erste Lambda Term muss aber nicht unbedingt eine Abstraktion sein. Er kann auch eine Variable oder eine Applikation sein. In diesem Fall wird der zweite Lambda Term als Argument an den ersten Lambda Term übergeben. Ein Beispiel für eine Applikation ist $((\lambda x.x) \; y)$ welches die Identitätsfunktion mit dem Argument $y$ aufruft und dabei $y$ zurückgibt.

\doublelinebreak
Um die Notation zu vereinfachen gibt es einige Konventionen die in der Literatur verwendet werden.
Zunächst soll Applikation linksassoziativ sein, d.h. $(t_1 \; t_2 \; t_3)$ soll als $((t_1 \; t_2) \; t_3)$ interpretiert werden. Bei einer langen Applikation werden also immer die ersten beiden Terme zuerst ausgewertet und das Ergebnis dann mit dem nächsten Term verknüpft. Die Abstraktion hingegen bindet immer so weit wie möglich nach Rechts. $(\lambda x.x \; x)$ wird also nicht als Applikation von $(\lambda x.x)$ auf $(x \; x)$ interpretiert sondern als Abstraktion von $x$ auf $(x \; x)$. Mit explizieter Klammerung wird der Lambda Term also als $(\lambda x.(x \; x))$ geschrieben. Mit diesen Vereinfachungen kann ein komplexer Lambda Term wie
\begin{align*}
    (\lambda x.(\lambda y.(\lambda z.((x \; z) \; (y \; z)))))
\end{align*}
mit der folgenden Schreibweise dargestellt werden:
\begin{align*}
    (\lambda x. \lambda y. \lambda z. x \; z \; (y \; z)).
\end{align*}

\doublelinebreak

\subsubsection{Alpha-Äquivalenz}

\subsubsection{Beta Reduktion}

\subsubsection{De-Bruijn-Indizes}

\subsection{Auswertung von Programmiersprache im Algemeinen}

grundlegegende dinge zu compilern und interpretern um später unsere eigene Sprache zu implementieren

\subsubsection{Tree-Walk Interpreter}

\subsubsection{Hieracrhie der Analyse - Lexer, Parser, Interpreter}


\section{Design und Implementierung des Interpreters}

\subsection{Beschreibung der Programmiersprache Lambo}

\subsubsection{Syntax und Semantic}

currying muss 
\subsubsection{Beispiele für Lambo-Code}

\subsection{Wahl des Tree-Walk-Interpreters für Lambo}

\subsection{Implementierung des Interpreters}

\subsubsection{Lexer}

\subsubsection{Parser}

currying muss rein irgendwo

\subsubsection{De-Bruijn-Indizes}

\subsubsection{interpreter}

\subsection{Herausforderungen und Lösungen - Limitierungen der Implementation}


\section{Evaluation und Tests}

\subsection{Konstruktion von Natürlichen Zahlen, Boolean Artimethik und Listen}

\subsection{Performance-Analyse des Interpreters}

\subsection{Vergleich mit anderen Interpretern}


\section{Zusammenfassung, Fazit und Ausblick}

\subsection{Mögliche Anwendungen von Lambo}

\subsection{Potenzielle Erweiterungen des Interpreters}

\subsection{Zukünftige Entwicklungsrichtungen}

\subsection{Zusammenfassung der Ergebnisse}

\subsection{Schlussfolgerungen und Ausblick}

%\printbibliography
\end{document}
