\documentclass[ngerman]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{csquotes}
\MakeOuterQuote{"}

\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[style=ieee]{biblatex}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{titling}

\addbibresource{literatur.bib}

\newcommand{\subtitle}[1]{
  \posttitle{
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.5em}%
}

\newcommand{\doublelinebreak}{\par\vspace{\baselineskip}}

\title{Implementierung eines Interpreters für eine rudimentäre Programmiersprache auf Basis des untypisierten Lambda-Kalküls unter Verwendung von De-Bruijn-Indizes}
\author{Marvin Mielchen}
\subtitle{Hausarbeit aus dem Seminar: Grundlagen und Meilensteine der funktionalen Programmierung}
\date{\today}

\begin{document}

\maketitle

%\cite[S. 8]{nystrom}
- es muss einen Teil in der Arbeit geben der sich mit den Limitierungen der Arbeit beschäftigt
    - probleme mit rekusion in lambo
    - probleme mit speicher in lambo: z.B. sind while schleifen über große arrays wahrscheinlich nicht möglich weil alle expressions ausgewertet werden müssen und
    das also nicht "echt" iterativ ist
    - usw.
- DER Lambda Kalkül (üpberall ausbessern)

\section{Einleitung}

\subsection{Hintergrund und Motivation}

Im Jahr 1936 veröffentlichte Alonzo Church seine Arbeit (AUSFÜLLEN!!!) in der er den Lambda-Kalkül einführte. 
Der Lambda-Kalkül ist eine formale Sprache, die zur Untersuchung von Funktionen und deren Auswertung dient. Er ist die Grundlage der funktionalen Programmierung und hat einen großen Einfluss auf die Entwicklung von Programmiersprachen wie Lisp, ML, Haskell und vielen anderen.
Mit dem Lambda-Kalkül gibt es neben dem gängigen Modell der Turingmaschine ein weiteres Modell der Berechenbarkeit. Alle Berechnungen, die mit einer Turingmaschine durchgeführt werden können, können auch mit dem Lambda-Kalkül durchgeführt werden und umgekehrt.
Gleichzeitig entsprechen die Probleme die von Turingmaschinen gelöst werden können genau den intuitiv berechenbaren Problemen und das gilt so also auch für die Probleme, die mit dem Lambda-Kalkül modeliert werden können.
Der Lambda-Kalkül ist also ein universelles Modell der Berechenbarkeit und ist damit ein wichtiger Bestandteil der theoretischen Informatik. Viele Funktionale Sprachen werden auf den Grundlagen des Lambda Kalküls aufgebaut obwol unsere modernen Rechner mit ihrer von Neuman Architektur (CITE!) eher zu dem Modell der Turingmaschine passen.
Wie ein komplex verschachtelter Lambda Ausdruck mit einem imperativen System ausgewertet werden kann ist also eine interressante und komplizierte Problemstellung und soll die Motivation für diese Arbeit sein.

\subsection{Ziel der Hausarbeit}

- es soll auf der basis des untypisierten lambda Kalküls eine Sprache entwickelt werden die turingvollstäding (wenn auch nicht praktisch ist)
    - es werden also nur die allernötigsten features implementiert und entscheidende Eigenschaften einer "nützlichen" Sprache gegen Funktionalität eingetauscht die eine einfache und verständliche Interaktion mit den Regeln des Lambda Kalküls ermöglichen
- es soll ein Tree-Walk Interpreter entwickelt werden der die Sprache auswertet und dabei grundlegenden Anforderungen an einen modernen Interpreter und Ansprüchen an solche Implementationen zumindest im Ansatz gerecht wird 
- (optional) villeicht noch evaluation in irgendeiner form und vergleich mit anderen Sprachen 
- auch limitierungen der implementation betrachten (die sind schon schwerwiegend)

- im Anhang kann noch auf die Website eingegangen werden die eine Interaktion mit der entwickelten Sprache ermöglicht

\subsection{Übersicht über die folgenden Abschnitte}

\section{Grundlagen}

\subsection{Syntax und Regeln im untypisierten Lambda-Kalkül !!ZITATE!!}

Der untypisierte Lambda-Kalkül beschreibt eine formale Sprache, die zur Definition und Analyse von Funktionen verwendet wird und dieselbe Klasse von berechenbaren Funktionen definiert wie die Turing-Maschine.
In der einfachsten Form lässt sich diese Sprache wie folgt rekursiv in Bakus Naur Form definieren:
\begin{align*}
    \text{\textless term\textgreater} & ::= \text{\textless variable\textgreater} \\
                      & \; | \; ( \lambda \text{\textless variable\textgreater} . \text{\textless term\textgreater} )\\
                      & \; | \; (\text{\textless term\textgreater} \; \text{\textless term\textgreater})
\end{align*}
Ein Lambda Term is dabei in einer der drei definierten Formen, wobei diese wiederum aus verschachtelten Lambda Termen bestehen können.

Eine Variable $\text{\textless variable\textgreater}$ kann im Lambda-Lalkül eine beliebige Zeichenketten sein (z.B. "x" oder "supervar") soweit keine der folgenden Zeichen enthalten ist: $\lambda$ . ( ). Variablen werden dabei als Platzhalter für beliebige Lambda Terme verwendet oder als formale Parameter von Abstraktionen und können dabei auch mehrfach in einem Lambda Term vorkommen.

$(\lambda \text{\textless variable\textgreater} . \text{\textless term\textgreater})$ heist Abstraktion und representiert eine Funktion. Die Variable ist dabei der formale Funktionsparameter und der Lambda Term nach dem Punkt ist der Funktionskörper. Ein Beispiel für eine Abstraktion ist die Identitätsfunktion $(\lambda x.x)$ welche ein Argument entgegennimmt und dieses unverändert zurückgibt.

$(\text{\textless term\textgreater} \; \text{\textless term\textgreater})$ heist Applikation und representiert den Aufruf einer Funktion. Der erste Lambda Term ist dabei die Funktion und der zweite Lambda Term ist das Argument. Die Applikation wird dabei von links nach rechts ausgewertet. Der erste Lambda Term muss aber nicht unbedingt eine Abstraktion sein. Er kann auch eine Variable oder eine Applikation sein. In diesem Fall wird der zweite Lambda Term als Argument an den ersten Lambda Term übergeben. Ein Beispiel für eine Applikation ist $((\lambda x.x) \; y)$ welches die Identitätsfunktion mit dem Argument $y$ aufruft und dabei $y$ zurückgibt.

\doublelinebreak
Um die Notation zu vereinfachen gibt es einige Konventionen die in der Literatur verwendet werden.
Zunächst soll Applikation linksassoziativ sein, d.h. $(t_1 \; t_2 \; t_3)$ soll als $((t_1 \; t_2) \; t_3)$ interpretiert werden. Bei einer langen Applikation werden also immer die ersten beiden Terme zuerst ausgewertet und das Ergebnis dann mit dem nächsten Term verknüpft. Die Abstraktion hingegen bindet immer so weit wie möglich nach Rechts. $(\lambda x.x \; x)$ wird also nicht als Applikation von $(\lambda x.x)$ auf $x$ interpretiert sondern als Abstraktion von $x$ auf $(x \; x)$. Mit explizieter Klammerung wird der Lambda Term also als $(\lambda x.(x \; x))$ geschrieben. Mit diesen Vereinfachungen kann ein komplexer Lambda Term wie
\begin{align*}
    (\lambda x.(\lambda y.(\lambda z.((x \; z) \; (y \; z)))))
\end{align*}
mit der folgenden Schreibweise dargestellt werden:
\begin{align*}
    (\lambda x. \lambda y. \lambda z. x \; z \; (y \; z)).
\end{align*}

\doublelinebreak

Ein sinvoller Äquivalenzbegriff für Lambda Terme ist die $\alpha$-Äquivalenz. Zwei Lambda Terme sind genau dann $\alpha$-Äquivalent, wenn sie sich nur in der Wahl der Variablennamen unterscheiden. Die folgenden Terme sind also $\alpha$-Äquivalent: $(\lambda x.x)$ und $(\lambda y.y)$.
Als $\alpha$-Konversion (geschrieben $\rightarrow_\alpha$) wird die Umbenennung von Variablen bezeichnet. Dabei wird eine Variable in einem Lambda Term durch eine andere Variable ersetzt wobei dabei keine freien Variablen gebunden werden dürfen. Zwei Terme sind auch genau dann $\alpha$-Äquivalent, wenn sie durch $\alpha$-Konversion ineinander überführt werden können.

\doublelinebreak

%Beta-Reduktion
Die Auswertung von Lambda Termen wird durch die $\beta$-Reduktion (geschrieben $\rightarrow_\beta$) beschrieben.
Dabei wird eine Applikation $((\lambda x.t_1) \; t_2)$ durch die Substitution von $t_2$ für $x$ in $t_1$ ersetzt. Die Substitution wird dabei so durchgeführt, dass keine freien Variablen gebunden werden. Die folgenden Beispiele sollen diesen Zusammenhang verdeutlichen:
\begin{align*}
    ((\lambda x.x) \; y)
\end{align*}
kann direkt durch die Substitution von $y$ für $x$ in $(\lambda x.x)$ ersetzt werden. Da in diesem Fall keine freien Variablen gebunden wird, kann die Substitution direkt durchgeführt werden und die Reduktion ergibt
\begin{align*}
    ((\lambda x.x) \; y) \rightarrow_\beta y.
\end{align*}
Das folgende Beispiel ist etwas komplexer:
\begin{align*}
    ((\lambda x.\lambda y.x \; y) \; y)
\end{align*}
Hier wird $y$ für $x$ in $\lambda y.x \; y$ substituiert. Da $y$ in $\lambda y.x \; y$ vorkommt, muss $y$ in $\lambda y.x \; y$ umbenannt werden damit das freie $y$ nicht gebunden wird. Es ergibt sich also
\begin{align*}
    ((\lambda x.\lambda y.x \; y) \; y) \rightarrow_\alpha ((\lambda x.\lambda z.x \; z) \; y) \rightarrow_\beta (\lambda z.y \; z).
\end{align*}

\doublelinebreak
Das sind alle Regeln die für den untypisierten Lambda-Kalkül benötigt werden. Mit diesen Regeln können alle berechenbaren Funktionen beschrieben werden wie sie auch mit einer Turingmaschine modeliert werden können.
Allerdings soll jetzt noch auf die De-Bruijn-Indizes eingegangen werden, die eine alternative Darstellung von Lambda Termen ermöglichen und die Implementierung eines Interpreters vereinfachen.

\subsection{De-Bruijn-Indizes}

Für die eben diskutierte $\beta$-Reduktion und die $\alpha$-Konversion gibt es einen entscheidenden Vorgang der sich für einen allgemeinen Lambda Term als schwierig erweist.
Bei beiden Äquivalentumformungen dürfen keine freien Variabeln gebunden werden und deshalb müssen kollidierende Variablen gefunden und umbenannt werden.
De-Bruijn-Indizes sind eine alternative Darstellung von Lambda Termen, bei denen dieses Problem deutlich vereinfacht wird weil die Variablen hier nicht mithilfe von Namen sondern mithilfe von Indizes identifiziert werden die nur von der Struktur des Lambda Terms abhängen.

Für einen Lambda Term in der Notation mit De-Bruijn Indizes verändert sich die Definition der Syntax wie folgt:
\begin{align*}
    \text{\textless term\textgreater} & ::= \text{\textless index\textgreater} \\
                      & \; | \; ( \lambda \text{\textless term\textgreater} )\\
                      & \; | \; (\text{\textless term\textgreater} \; \text{\textless term\textgreater})
\end{align*}
Ein Lambda Term ist also entweder ein Index, eine Abstraktion oder eine Applikation. Ein Index ist dabei eine natürliche Zahl die angibt wie weit der nächste Binder entfernt ist. Ein Index $0$ steht dabei für den nächsten Binder, ein Index $1$ für den übernächsten Binder und so weiter. Die folgenden Beispiele sollen diese Notation verdeutlichen:
\begin{align*}
    (\lambda x.x), (\lambda y.y), (\lambda z.z), usw.
\end{align*}
werden mit De-Bruijn-Indizes zu
\begin{align*}
    (\lambda 1).
\end{align*}
Die Identitätsfunktion kann mit der herkömmlichen Notation auf beliebig viele Arten dargestellt werden aber mit De-Bruijn-Indizes gibt es nur eine Möglichkeit. Der Index $1$ steht dabei für den nächsten Binder, also für das $\lambda$ und bedeutet bei der Substitution dass diese Variable dann ersetzt wird wenn das erste bindende $\lambda$ entfernt wird. 

Betrachten wir nun noch den komplizierteren Term
\begin{align*}
    (\lambda z.((\lambda y.y) \; (\lambda x.x)) \; (\lambda x.z \; x)).
\end{align*}
Mit De-Bruijn-Indizes lässt sich dieser mit
\begin{align*}
    (\lambda ((\lambda 1) \; (\lambda 1)) \; (\lambda 2 \; 1))
\end{align*}
darstellen. Die gebundenen $y$, $x$ und $z$ werden dabei alle durch den Index $1$ dargestellt weil sie alle nur ein $\lambda$ von ihrem Binder entfernt sind. $z$ hingegen bekommt den Index $2$ weil es zwei $\lambda$ von seinem Binder entfernt ist.

%HIER GEHTS WEITER

%Auswertungsstrategien

\subsection{Auswertung von Programmiersprache im Allgemeinen}

grundlegegende dinge zu compilern und interpretern um später unsere eigene Sprache zu implementieren

\subsubsection{Tree-Walk Interpreter}

\subsubsection{Hieracrhie der Analyse - Lexer, Parser, Interpreter}


\section{Design und Implementierung des Interpreters}

\subsection{Beschreibung der Programmiersprache Lambo}

\subsubsection{Syntax und Semantic}

currying muss 
\subsubsection{Beispiele für Lambo-Code}

\subsection{Wahl des Tree-Walk-Interpreters für Lambo}

\subsection{Implementierung des Interpreters}

\subsubsection{Lexer}

\subsubsection{Parser}

currying muss rein irgendwo

\subsubsection{De-Bruijn-Indizes}

\subsubsection{interpreter}

\subsection{Herausforderungen und Lösungen - Limitierungen der Implementation}


\section{Evaluation und Tests}

\subsection{Konstruktion von Natürlichen Zahlen, Boolean Artimethik und Listen}

\subsection{Performance-Analyse des Interpreters}

\subsection{Vergleich mit anderen Interpretern}


\section{Zusammenfassung, Fazit und Ausblick}

\subsection{Mögliche Anwendungen von Lambo}

\subsection{Potenzielle Erweiterungen des Interpreters}

\subsection{Zukünftige Entwicklungsrichtungen}

\subsection{Zusammenfassung der Ergebnisse}

\subsection{Schlussfolgerungen und Ausblick}

%\printbibliography
\end{document}
